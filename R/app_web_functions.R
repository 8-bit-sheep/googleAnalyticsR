#' Returns multiple reports in a batch. All reports must be for the sameEntity.
#'
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_skeleton}}
#'
#' @seealso \href{https://developers.google.com/analytics/trusted-testing/analytics-data/}{Google Documentation}
#'
#' @details
#'
#' @param BatchRunReportsRequest The \link{BatchRunReportsRequest} object to pass to this method
#' #' @importFrom googleAuthR gar_api_generator
#' @family BatchRunReportsRequest functions
#' @export
google_analytics_aw <- function(propertyId,
                                metrics,
                                date_range,
                                dimensions,
                                dimensionFilter = NULL,
                                metricFilter = NULL,
                                orderBys = NULL,
                                limit = 100) {
  url <- "https://analyticsdata.googleapis.com/v1alpha:batchRunReports"
  
  assert_that_ifnn(dimensionFilter, is.FilterExpression)
  assert_that_ifnn(metricFilter, is.FilterExpression)
  assert_that_ifnn(orderBys, is.OrderBy)
  
  brrr <- BatchRunReportsRequest(
    entity = Entity(propertyId),
    requests = list(
      RunReportRequest(
        metrics = lapply(metrics, function(x) Metric(name = x)),
        dimensions = lapply(dimensions, function(x) Dimension(name = x)),
        dateRanges = date_ga4(date_range),
        limit = limit,
        dimensionFilter = dimensionFilter,
        metricFilter = metricFilter,
        orderBys = orderBys,
        keepEmptyRows = TRUE,
        returnPropertyQuota = TRUE
      )
    )
  )
  
  parse_batchrunreports <- function(x){
    o <- x$reports

    the_data <- lapply(o$rows, function(x){
      o <- cbind(get_value_cols(x, type = "dimensionValues"),
                 get_value_cols(x, type = "metricValues"))
      # get col names from parent environment
      setNames(o, c(dimensions, metrics))
    })
    
    res <- Reduce(rbind, the_data)
    attr(res, "propertyQuota") <- o$propertyQuota
    attr(res, "metadata") <- if(ncol(o$metadata) > 0) o$metadata else NULL
    
    res
  }
  
  
  # analyticsdata.batchRunReports
  f <- gar_api_generator(url, "POST", 
                         data_parse_function = parse_batchrunreports)
  
  stopifnot(inherits(brrr, "gar_BatchRunReportsRequest"))
  o <- f(the_body = brrr)
  
  o
}

#' Create a filter for use within App+Web filter expressions
#' 
#' Used within \link{ga_aw_filter_expr}
#' 
#' @param field The dimension or metric field name
#' @param value The value - filter type is based on what class of object
#' @param operation How the filter operates on field with value
#' @param caseSensitive For character based value filters
#' 
#' @details 
#' 
#' Ensure your value is of the right class for the type of filter you desire:
#' 
#' \itemize{
#'   \item{character: string filter}
#'   \item{character vector: in list filter}
#'   \item{numeric: Numeric filter}
#'   \item{numeric 2-length vector: between filter}
#'  }
#' 
#' For numerics also make sure to specify integer or float for metrics e.g.
#' 1L or 1.00
#' 
#' @export
#' @importFrom assertthat is.string is.count
ga_aw_filter <- function(field,
                         value, 
                         operation = c("EXACT",
                                       "BEGINS_WITH",
                                       "ENDS_WITH",
                                       "CONTAINS",
                                       "FULL_REGEXP",
                                       "PARTIAL_REGEXP",
                                       "EQUAL",
                                       "LESS_THAN",
                                       "LESS_THAN_OR_EQUAL",
                                       "GREATER_THAN",
                                       "GREATER_THAN_OR_EQUAL"),
                         caseSensitive = TRUE){
  
  if(is.string(value)){
    assert_that(operation %in% c("EXACT",
                                 "BEGINS_WITH",
                                 "ENDS_WITH",
                                 "CONTAINS",
                                 "FULL_REGEXP",
                                 "PARTIAL_REGEXP"))
    o <- Filter_aw(field, 
                   stringFilter = StringFilter(
                     value,
                     matchType = operation,
                     caseSensitive = caseSensitive
                   ))
  } else if(is.character(value)){
    o <- Filter_aw(field,
                   inListFilter = InListFilter(
                     value,
                     caseSensitive = caseSensitive
                   ))
  } else if(is.count(value)){
    assert_that(operation %in% c("EQUAL",
                                 "LESS_THAN",
                                 "LESS_THAN_OR_EQUAL",
                                 "GREATER_THAN",
                                 "GREATER_THAN_OR_EQUAL"))
    o <- Filter_aw(field,
                   numericFilter = NumericFilter(
                     value,
                     operation = operation
                   ))
  } else if(is.numeric(value) && length(value) == 2){
    o <- Filter_aw(field,
                   betweenFilter = BetweenFilter(
                     fromValue = value[[1]],
                     toValue = value[[2]]
                   ))
  } else {
    stop("Didn't know what to do with value of type: ", class(value), 
         call. = FALSE)
  }
  
  o
  
}

#' Create a filter expression for use with App+Web Reports
#' 
#' For use with \link{google_analytics_aw}
#' 
#' @param a_filter A Filter object or a FilterExpression or a list of FilterExpressions
#' @param type The type of filter
#' 
#' @details The fields in the same FilterExpression need to be either all dimensions or all metrics.
#' 
#' @export
ga_aw_filter_expr <- function(...,
                              type = c("default","not","and","or")){
  
  type <- match.arg(type)
  
  dots <- list(...)
  
  if(length(dots) == 1){
    a_filter <- dots[[1]]
  }
  
  if(type == "default"){
    assert_that(is.Filter(a_filter))
    o <- FilterExpression(filter = a_filter)
  } else if(type == "not"){
    assert_that(is.FilterExpression(a_filter))
    o <- FilterExpression(notExpression = a_filter)
  } else if(type == "and"){
    assert_that(is.list(a_filter))
    filter_list <- FilterExpressionList(a_filter)
    o <- FilterExpression(andGroup = filter_list)
  } else if(type == "or"){
    assert_that(is.list(a_filter))
    filter_list <- FilterExpressionList(a_filter)
    o <- FilterExpression(orGroup = filter_list)
  }
  
  o
  
}



#' @noRd
#' @importFrom tibble as_tibble
get_value_cols <- function(x, 
                      type = c("dimensionValues", "metricValues")){
  type <- match.arg(type)
  as_tibble(
    do.call(rbind, lapply(x[[type]], function(y) y[["value"]])),
    .name_repair = "minimal")
} 

